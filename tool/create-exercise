#!/usr/bin/env dart
// vim: set syntax=dart:

import "dart:io";
import "dart:async";
import "dart:convert";
import "package:args/args.dart";

/** Constants */
const ME = "create-exercise";

final parser = new ArgParser()
  ..addSeparator("Usage: $ME <slug> [--spec-path path]")
  ..addOption("spec-path", help: "The location of the problem-specifications directory.", valueHelp: 'path');

/** Helpers */
List<String> words(String str) {
  return str
      .toLowerCase()
      .replaceAll(new RegExp(r"[^a-z0-9]"), " ")
      .replaceAll(new RegExp(r"\ +"), " ")
      .trim()
      .split(" ");
}

String upperFirst(String str) {
  final chars = str.split("");
  final first = chars.first;

  return first.toUpperCase() + chars.skip(1).join("");
}

String camelCase(String str, {bool isUpperFirst = false}) {
  final parts = words(str);
  final first = parts.first;
  final rest = parts.skip(1);

  return (isUpperFirst ? upperFirst(first) : first) + rest.map(upperFirst).join("");
}

String pascalCase(String str) => camelCase(str, isUpperFirst: true);

String snakeCase(String str) => words(str).join("_");

String kebabCase(String str) => words(str).join("-");

/** Templates */
String exampleTemplate(String name) => """
class ${pascalCase(name)} {

}
""";

String mainTemplate(String name) => """
class ${pascalCase(name)} {
  // Put your code here
}
""";

String testCasesString = """
    test("should work", () {
      // TODO
    });""";

String testTemplate(String name) => """
import "package:test/test.dart";
import "package:${snakeCase(name)}/${snakeCase(name)}.dart";

void main() {
  final ${camelCase(name)} = new ${pascalCase(name)}();

  group("${pascalCase(name)}", () {
$testCasesString
  });
}
""";

String pubTemplate(String name) => """
name: '${snakeCase(name)}'
dev_dependencies:
  test: '<0.13.0'
""";

String testCaseTemplate(name, testCase) {
  if (testCase['cases'] != null) {
    // We have a group, not a case
    String tests = testCase['cases'].map((c) => testCaseTemplate(name, c)).join("\n");
    String description = testCase['description'];

    if (description == null) {
      return tests;
    }

    return """
      group("$description", () {
        $tests
      });
    """;
  }

  String description = repr(testCase['description']);
  String resultType = getFriendlyType(testCase['expected']);
  String object = camelCase(name);
  String method = camelCase(testCase['property']);
  String expected = repr(testCase['expected']);

  List<String> inputKeys = testCase.keys.toList()..remove("expected")..remove("description")..remove("property");
  String arguments = inputKeys.map((k) => repr(testCase[k])).join(", ");

  return """
    test($description, () {
      final $resultType result = $object.$method($arguments);
      expect(result, equals($expected));
    }, skip: true);
  """;
}

/// `repr` takes in any object and tries to coerce it to a String in such a way that it is suitable to include in code.
/// Based on the python `repr` function, but only works for basic types: String, Iterable, Map, and primitive types
String repr(Object x) {
  if (x is String) {
    x = x.replaceAll("\n", r"\n").replaceAll(r"$", r"\$");
    return '"$x"';
  }

  if (x is Iterable) {
    return '[${x.map(repr).join(", ")}]';
  }

  if (x is Map) {
    List<String> pairs = [];
    for (var k in x.keys) {
      pairs.add("${repr(k)}: ${repr(x[k])}");
    }

    return "{${pairs.join(', ')}}";
  }

  return "$x";
}

/// A helper method to get the inside type of an iterable
String getIterableType(Object iter) {
  Set<String> types = iter.map(getFriendlyType).toSet();

  if (types.length == 1) {
    return types.first;
  }

  return "Object";
}

/// Get a human-friendly type of a variable
String getFriendlyType(Object x) {
  if (x is String) {
    return "String";
  }

  if (x is Iterable) {
    return "List<${getIterableType(x)}>";
  }

  if (x is Map) {
    return "Map<${getIterableType(x.keys)}, ${getIterableType(x.values)}>";
  }

  if (x is num) {
    return "num";
  }

  return x.runtimeType;
}

Future main(args) async {
  final arguments = parser.parse(args);
  final restArgs = arguments.rest;

  if (restArgs.isEmpty) {
    stderr.write(parser.usage);
    exit(1);
  }

  final name = restArgs.first;

  // Create dir
  final currentDir = Directory.current;
  final exerciseDir = new Directory("exercises/${kebabCase(name)}");
  final filename = snakeCase(name);

  // Get test cases from canonical-data.json, format tests
  if (arguments["spec-path"] != null) {
    String filename = "${arguments['spec-path']}/exercises/$name/canonical-data.json";
    try {
      File file = new File(filename);
      final specification = JSON.decode(await file.readAsString());
      testCasesString = testCaseTemplate(name, specification);
    } on FileSystemException {
      stderr.write("Could not open file '$filename', exiting.\n");
      exit(1);
    } on FormatException {
      stderr.write("File '$filename' is not valid JSON, exiting.\n");
      exit(1);
    }
  }

  if (await exerciseDir.exists()) {
    stderr.write("$name already exist");
    exit(1);
  }

  await new Directory("${exerciseDir.path}/lib").create(recursive: true);
  await new Directory("${exerciseDir.path}/test").create(recursive: true);

  // Create files
  String testFileName = "${exerciseDir.path}/test/${filename}_test.dart";
  await new File("${exerciseDir.path}/lib/example.dart").writeAsString(exampleTemplate(name));
  await new File("${exerciseDir.path}/lib/${filename}.dart").writeAsString(mainTemplate(name));
  await new File(testFileName).writeAsString(testTemplate(name));
  await new File("${exerciseDir.path}/pubspec.yaml").writeAsString(pubTemplate(name));

  if (arguments["spec-path"] != null) {
    // The output from test generation is not always well-formatted, use dartfmt to clean it up
    final res = await Process.run("dartfmt", ["-l", "120", "-w", testFileName], runInShell: true);
    if (!res.stdout.toString().isEmpty) {
      stdout.write(res.stdout);
    }

    if (!res.stderr.toString().isEmpty) {
      stderr.write(res.stderr);
    }

    if (res.exitCode != 0) {
      stderr.write("Warning: dartfmt exited with a code of ${res.exitCode}, '$testFileName' is likely malformed.\n");
    }
  }

  // Install deps
  Directory.current = exerciseDir;

  final res = await Process.run("pub", ["get"], runInShell: true);

  if (!res.stdout.toString().isEmpty) {
    stdout.write(res.stdout);
  }

  if (!res.stderr.toString().isEmpty) {
    stderr.write(res.stderr);
  }

  assert(res.exitCode == 0);

  Directory.current = currentDir;
}
